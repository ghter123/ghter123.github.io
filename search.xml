<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[数据结构]--单调队列]]></title>
    <url>%2F2020%2F06%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5D--%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[单调队列单调队列的重点在维护队列的单调性（递增，或者递减）。它定义了三种出入队列的操作：头出、尾出、尾进。头出:pop出最大（最小）的元素。尾出:配合push使用，根据单调性和push元素的值，将小于（大于）push元素的队尾元素出队。尾进:就是将数据插入队列。 12345678910111213141516171819202122232425262728293031class MonotoneQueue &#123; constructor(comparator) &#123; this.queue = [] this.comparator = comparator &#125; push(val) &#123; while (!this.isEmpty()) &#123; if (this.comparator(this.Last, val)) break this.queue.pop() &#125; this.queue.push(val) &#125; pop() &#123; return this.isEmpty() ? null : this.queue.shift() &#125; isEmpty() &#123; return this.queue.length &lt;= 0 &#125; get First() &#123; return this.isEmpty() ? null : this.queue[0] &#125; get Last() &#123; return this.isEmpty() ? null : this.queue[this.queue.length - 1] &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[精通Git]GitLab实战]]></title>
    <url>%2F2020%2F02%2F04%2F%E7%B2%BE%E9%80%9AGit%2Fgitlab%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[GitLab简介 一个基于Git的在线代码托管平台。 安装、部署GitLab具体的方法请参考官网文档 工作流简介在这里的工作流是为了解决软件开发中的开发、发布、部署等这几个阶段的版本管理和流程问题。Git作为一个灵活的版本管理工具，人们根据用户量，发布的频率，质量的要求等结合它设计了许多种工作流。就目前来说比较常见的有三种。我会都介绍他们，但是最后只会结合GitLab演示第三种。 Git工作流这种工作流主要包含以下大类分支。 master分支（主分支，长期分支） develop分支（开发分支，长期分支） 协助分支 feature分支（新功能分支） hotfix分支（修复bug的分支） release分支（发布分支） 我们结合图片很容易理解它的开发流程： 建立master分支 由master分支派生develop分支 由develop分支派生feature分支开发新功能 feature分支开发完后合并回develop 重复3-4 阶段性完成功能之后由develop派生release分支 将需要部署的release分支合并到master分支 [可选]假设线上出了bug，需要紧急修复，则从master分支派生hotfix分支，修复bug之后，合并回develop分支和master分支。 这种工作流能够适应各种开发和发布部署的版本管理需求，但是它需要维护两个长期分支。 GitHub工作流。这种工作流非常的简单，只有master和feature两种分支。它的开发流程： 从master分支派生一个feature分支 开发人员提交commit 提交pull request 参与人员在线discuss和review 部署 将pull request合并入master 这种工作流只需要维护一个长期分支master，而且它有一个原则，即任何时候master都是线上版本。但是这种假设不一定总是成立的，因为有时候master不一定能直接部署到线上，它可能受限于公司的流程需要一定的滞后时间才能部署，这时候就出现了线上和master不一致。很明显这种工作流并不能适应这种情况。 GitLab工作流。GitLab工作流与GitHub工作流在开发阶段上面是一样的，只需要依赖长期分支master分支和feature分支，feature分支直接从master分支派生。但是它还增加了两种分支对发布和部署提供版本管理支持。 环境分支 发布分支 这里补充它的一个原则“上游优先”原则，就是说所有的分支都应该从它的上游派生，不应该越级。比如：Production应该从Pre-Production，而不是Master。]]></content>
      <categories>
        <category>精通Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[深入理解ES6]--第一篇]]></title>
    <url>%2F2019%2F04%2F17%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%2F%5B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%5D--%E7%AC%AC%E4%B8%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[let和const声明之前使用var声明变量的话，首先会查看之前是否声明过同名变量，如果声明过，则覆盖掉之前的声明，如果没有，则本次声明会生效，声明一个新变量。123var a = 1;var a = 2;console.log(a); //2 ES6引入了let和const声明，let声明与var声明大体差不多，但是let声明，在同一个作用域内，变量名是唯一的，如果重复声明，则会报错.12345678910 let a = 1; let a = 2;//报错，Uncaught SyntaxError: Identifier 'a' has already been declared console.log(a);//////////////////////////////////// let a = 1; function test()&#123; let a = 2; console.log(a);//2，因为两次let声明不在同一作用域内 &#125; test(); const声明与let声明一样，同一个作用域内，不能声明重名变量，不一样的是，const声明的是一个常量，声明过后不能对该变量进行修改，否则就会报错。在编写代码的过程中，我们最好养成使用const声明的习惯，除非不得已的情况下，再使用let，这样是为了预防变量声明后，被预期外的情况修改。123const a = 1;a = 2; //报错：TypeError: Assignment to constant variableconsole.log(a); 模板表达式ES6中引入了反引号来表示字符串，称之为模板表达式，模板表达式的优点如下： 字符串换行之前JS为了实现字符串换行采用了很多手段，结果是我们想要的了，但是代码着实麻烦，使用模板表达式实现字符串换行，直接回车就行,需要注意的是，使用模板字符串进行进行换行时，如果添加了空格符号，也是会被渲染的，具体可以看第三个栗子。 12345678910111213141516171819//之前实现字符串换行const str = "string\ndahk"console.log(str); //string//dahk//使用模板表达式实现字符串换行const str = `stringdahk`console.log(str.length); //11console.log(str); //string//dahk//空格对模板表达式的影响const str = `string dahk`console.log(str.length); //15console.log(str); //string// dahk 引入js表达式ES6之前组合js变量与字符串是通过”+”符号，而在模板表达式中只需要使用$与一对大括号“{}”即可。 1234567891011121314151617//ES6之前引入变量const testStr = "test"const str = "string" + testStr;console.log(str); //stringtest//使用模板表达式引入变量const testStr = "test"const str = `string$&#123;testStr&#125;`console.log(str); //stringtest//使用模板表达式引入js表达式const amount = 10;const price = 3.5;const totalMoney = `总价钱为：$$&#123;amount*price&#125;`; console.log(totalMoney); //总价钱为：$35 解构获取数组或者对象的值，并将一些特殊值赋值给本地变量的过程就叫做解构。 对象解构如果之前想要获取某个对象的属性值，我们需要如下的操作：12345678const obj = &#123; name:"xiaobei", age:18&#125;const name = obj.name;const age = obj.age;console.log(name); //"xiaobei"console.log(age); //18 如果对象的属性很少，你这样写，当然没什么问题，可如果对象有成千上万个属性呢？再这样做，就麻烦多了。使用解构大大简化这个过程。1234567const obj = &#123; name:"xiaobei", age:18&#125;const &#123;name,age&#125; = obj;console.log(name); //xiaobeiconsole.log(age); //18 需要注意的是，声明变量的名字必须与你想获取的对象的属性名相同，不然会得到undefined。，如果你想给属性名重命名，可以参考下列代码中的第二个栗子。与一般的赋值语句相反，被赋值的变量在：的右边。123456789101112131415const obj = &#123; name:"xiaobei", age:18&#125;const &#123;name1,age1&#125; = obj;console.log(name1); //undefinedconsole.log(age1); //undefinedconst obj = &#123; name:"xiaobei", age:18&#125;const &#123;name:name1,age:age1&#125; = obj;console.log(name1); //xiaobeiconsole.log(age1); //18 你也可以通过解构赋值给已声明变量,在这里需要注意的是，需要用（）将解构表达式括起来，不然编译器会把{}识别为一个块，js中是无法给块赋值的，所以就会报错。123456789const obj = &#123; name:"xiaobei", age:18&#125;let name = "beibei";let age = 20;(&#123;name,age&#125; = obj);console.log(name); //xiaobeiconsole.log(age); //18 你还可以通过解构获取对象的子属性。123456789101112const obj = &#123; name:"xiaobei", age:18, favourite:&#123; eat:"meat", play:"game" &#125;&#125;const &#123;name,age,favourite:&#123;eat&#125;&#125; = obj;console.log(name); //xiaobeiconsole.log(age); //18console.log(eat); //meat 数组解构数组解构与对象解构类似，首先来看一个简单的数组解构。123456const arr = [1,2,3];const [firstPara,secondPara] = arr;const [,,thirdPara] = arr;console.log(firstPara); //1console.log(secondPara); //2console.log(thirdPara); //3 你也可以通过剩余参数来获取数组的值1234const arr = [1,2,3];const [firstPara,...restParas] = arr;console.log(firstPara); //1console.log(restParas); //[2,3] 我们之前交换两个变量的值，一般都是通过一个中间值，现在通过解构，完全不需要中间值，如下所示：12345let a = 1;let b = 2;[b,a] = [a,b];console.log(a); //2console.log(b); //1 上边的代码中，=右边创建了一个临时数组，然后复制了a,b的值并放入临时数组的前两项，然后通过解构赋值给已声明变量a,b。 混合使用解构在实践中，你也可以混合使用数组和对象解构。具体用法参考下列栗子。123456789101112131415const obj = &#123; name:"xiaobei", age:18, favourite:&#123; eat:"meat", play:"game" &#125;, d:[ 1,2 ]&#125;const &#123;favourite:&#123;play&#125;,d:[first]&#125; = obj;console.log(play);//gameconsole.log(first);//1]]></content>
      <categories>
        <category>深入理解ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[从零开始HTML5与CSS十]-列表]]></title>
    <url>%2F2019%2F03%2F27%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS3%2F%5B%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS%E5%8D%81%5D-%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[列表在页面中并不少见，我们这篇文章主要学习一下列表的相关知识 列表的种类 有序列表如果列表内容的顺序对列表是有影响的，那你可以选择有序列表，使用方法如下： 12345&lt;ol&gt; &lt;li&gt;apple&lt;/li&gt; &lt;li&gt;banana&lt;/li&gt; &lt;li&gt;orange&lt;/li&gt;&lt;ol&gt; 无序列表一般来说，无序列表的使用情况还是更多一点，使用方法如下： 12345&lt;ul&gt; &lt;li&gt;apple&lt;/li&gt; &lt;li&gt;banana&lt;/li&gt; &lt;li&gt;orange&lt;/li&gt;&lt;ul&gt; 描述性列表描述性列表一般是对某些事物进行详细解说，使用方法如下： 12345678910&lt;dl&gt; &lt;!--名称或术语--&gt; &lt;dt&gt;Boris Karloff&lt;/dt&gt; &lt;!--描述性内容--&gt; &lt;dd&gt;Best known for his role in &lt;cite&gt;Frankenstein&lt;/cite&gt; and related horror films, this scaremaster's real name was William Henry Pratt.&lt;/dd&gt; &lt;dt&gt;Christopher Lee&lt;/dt&gt; &lt;dd&gt;Lee took a bite out of audiences as Dracula in multiple Hammer horror classics.&lt;/dd&gt; &lt;dd&gt;Lee took a bite out of audiences as Dracula in multiple Hammer horror classics.&lt;/dd&gt;&lt;dl&gt; 一个dt可以对应一个或多个dd，也可以没有对应的dd。 列表标记 标记种类在样式表中，可以通过list-style-type属性定义列表选项左边的标记类型，可选择的类型有以下几种。 disc（圆点，●） circle（圆圈，○） square（方块，■） decimal（数字，1、2、3……） upper-alpha（ 大 写 字 母，A、B、C……） lower-alpha（ 小 写 字 母，a、b、c……） upper-roman（ 大 写 罗 马 数 字， Ⅰ、Ⅱ、 Ⅲ、 Ⅳ ……） lower-roman（小写罗马数字，i、ii、iii、iv……）可以有以下两种用法：12345678/*设置列表标记为小写字母*/ol,ul&#123; list-style-type:upper-alpha;&#125;/*下列语法与上列语法是同样效果，因为list-style-type是可继承属性*/li&#123; list-style-type:upper-alpha;&#125; 自定义标记如果现有的标记类型并不能满足你的需求，你可以设置自定义标记，首先需要通过list-style:none语法清除掉默认标记，然后自定义标记引入。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; ul&#123; /* 取消默认标记 */ list-style:none; /* 删除列表项的缩进 */ margin-left: 0; padding-left: 0; &#125; li&#123; /*background的样式规则： background: url(image.ext) repeattype horizontal vertical， 其中image.ext 是要作为定制标记的图像的路径和文件名，repeat-type 是 no-repeat、repeat-x 和repeat-y 中的一种（通常设为 no-repeat）， horizontal 和 vertical 值表示列表项目中背景图像的位置*/ background:url('./test.jpg') no-repeat 0 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;apple&lt;/li&gt; &lt;li&gt;banana&lt;/li&gt; &lt;li&gt;orange&lt;/li&gt; &lt;ul&gt; &lt;/body&gt;&lt;/html&gt; 看一下效果图，你会发现自定义图标与我们的列表内容重合了，所以我们需要为列表加一个内左边距，让标记和列表内容中间有一点空间，内左边距的大小不得小于自定义图标的宽度。修改&lt;li&gt;标签的样式规则如下,就可以如预期一般为我们的列表加上自定义标记了。1234li&#123; background:url('./test.jpg') no-repeat 0 0; padding-left:20px;&#125; 同类列表或者是不同类的列表都可以互相嵌套，但是一定要注意正确使用闭合标签，不要出现交叉的情况。]]></content>
      <categories>
        <category>从零开始HTML5与CSS3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[从零开始HTML5与CSS九]-使用CSS增强页面]]></title>
    <url>%2F2019%2F03%2F26%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS3%2F%5B%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS%E4%B9%9D%5D-%E4%BD%BF%E7%94%A8CSS%E5%A2%9E%E5%BC%BA%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[想要创建丰富布局的页面，就必然需要大量的HTML、CSS与图像文件，这样页面就变得更为复杂，浏览器需要花费更多的时间去加载和显示页面，同时页面也变得脆弱，难以维护。为了使页面不那么难以维护，我们这篇主要介绍通过CSS可以实现的一些功能，让页面加载的更快，用户体验更好。 使用CSS为元素设置圆角可以通过border-radius属性为元素设置圆角效果，属性值是长度，表示圆角的半径，如果你想在旧的浏览器或者是手机端的Safari中也使用border-radius属性，需要为其加上-webkit前缀。下列代码展示了该属性的一般用法：123456789101112131415161718192021div&#123; /*半径为10px的圆角*/ -webkit-border-radius:10px; border-radius:10px; /*左上角是半径为10px的圆角，其他为直角*/ -webkit-border-top-left-radius:10px; border-top-left-radius:10px; /*左上角和右下角是半径为10px的圆角，右上角和左下角是半径为15px的圆角*/ -webkit-border-radius:10px,15px; border-radius:10px,15px; /*左上角是半径为10px的圆角，其他为直角*/ -webkit-border-radius:10px,0,0; border-radius:10px,0,0; /*椭圆形圆角，20px是横轴的半径长度，50是纵轴的半径长度*/ -webkit-border-radius:20px/50px; border-radius:20px/50px; /*将元素设置为一个圆形*/ -webkit-border-radius:50%; border-radius:50%;&#125;![几种圆角效果图]([从零开始HTML5与CSS九]-使用CSS增强页面/test5.png) 为文字及元素添加阴影 为文字添加阴影为文字添加阴影是设置font-shadow属性，属性值有4个:x-offset（水平偏移量）、y-offset（垂直偏移量）、blur-radius（模糊半径）和color的值，前三个值带长度单位且均可以为0或者是整数，前两个值可正可负，第三个值必须为正数，四个值之间不用逗号分隔。下列代码展示了该属性的一般用法：12345678910111213141516171819202122p&#123; color: #222; /* 接近黑色 */ font-size: 4.5em; font-weight: bold;&#125;p &#123; text-shadow: 3px 3px #aaa;&#125;/* 负偏移值 */p &#123; text-shadow: -4px -2px #ccc;&#125;/* 模糊半径为10px */p &#123; text-shadow: 2px 2px 10px grey;&#125;/*可以为单个字体添加多个阴影样式，每组属性之间用逗号分隔。*/p &#123; text-shadow: 2px 2px white, 6px 6px rgba(50,50,50,.25);&#125; 为元素添加阴影为元素添加阴影是设置box-shadow属性，属性值有4个:x-offset（水平偏移量）、y-offset（垂直偏移量）、blur-radius（模糊半径）、可选的inset、可选的spread和color的值，前三个值带长度单位且均可以为0或者是整数，前两个值可正可负，第三个值必须为正数，四个值之间不用逗号分隔。下列代码展示了该属性的一般用法：1234567891011121314151617181920212223242526272829div &#123; /*为元素添加向右偏移4px,向下偏移4px,模糊半径为5px的阴影*/ -webkit-box-shadow: 4px 4px 5px #999; box-shadow: 4px 4px 5px #999;&#125;div &#123; /*为元素添加向左偏移4px,向上偏移4px,模糊半径为5px的阴影*/ -webkit-box-shadow: -4px -4px 5px #999; box-shadow: -4px -4px 5px #999;&#125;div &#123; /*为元素添加向右偏移4px,向下偏移4px,模糊半径为5px的阴影，扩张3px*/ -webkit-box-shadow: 4px 4px 5px 3px #999; box-shadow: 4px 4px 5px 3px #999;&#125;div &#123; /*为元素添加向右偏移2px,向下偏移2px,模糊半径为10px的阴影，向元素内部收缩的阴影*/ -webkit-box-shadow: 2px 2px 10px #666 inset; box-shadow: 2px 2px 10px #666 inset;&#125;/*可以为单个元素添加多个阴影样式，每组属性之间用逗号分隔。*/div &#123; -webkit-box-shadow: 2px 2px 10px rgba(255,0,0,.75), 5px 5px 20px blue; box-shadow: 2px 2px 10px rgba(255,0,0,.75), 5px 5px 20px blue;&#125; 渐变背景 线性渐变线性渐变即背景沿着某条线，逐渐发生改变，使用语法如下：1234567891011121314151617181920212223242526272829303132div&#123; /* 备用 */ background: silver; /*默认从上到下，由银色逐渐变为黑色*/ background: linear-gradient(silver, black);&#125;div &#123; background: silver; /*从下到上，由银色逐渐变为黑色*/ background: linear-gradient(to top,silver, black);&#125;div &#123; background: silver; /*从右到左，由银色逐渐变为黑色*/ background: linear-gradient(to left,silver, black);&#125;div &#123; background: silver; /*从左到右，由银色逐渐变为黑色*/ background: linear-gradient(to right,silver, black);&#125;/*指定渐变角度的度数*/div &#123; background: silver; background: linear-gradient(290deg,silver, black);&#125;div &#123; background: silver; /*从上到下，起点为0%，终点为100%，从0%至80%的位置银色逐渐变为红色，之后红色逐渐变为黑色*/ background: linear-gradient(to bottom, silver, red 80%, black);&#125; 第四条语法是指定渐变角度的度数，如90deg（90 度）。数值代表的是圆周上的点的位置：0代表最顶端的点，90代表最左边的点，180 代表最底端的点，270 代表最右边的点。你列出的值决定的是渐变结束的点的位置。因此0deg等价于to top，90deg 等价于to left，以此类推。 径向渐变也可以通过某一点以圆形的方式扩散，并且颜色逐渐改变。1234567891011121314151617181920div &#123; background: red; /* 默认从元素的中心向四周扩散 */ background: radial-gradient(yellow, red);&#125;div &#123; background: red; /* 指定中心点的位置在元素的顶部，由顶部中心点向四周扩散 */ background: radial-gradient(at top, yellow, red);&#125;div &#123; background: red; /*指定渐变的的范围（100px*50px），其余部分默认用红色填充 */ background: radial-gradient(100px 50px, yellow, red);&#125;div &#123; background: red; /*指定渐变的的范围（30px*30px），从黄色变为青橙色，其余部分用红色填充 */ background: radial-gradient(30px 30px at 65% 70%, yellow, lime, red);&#125; 多重背景可以为元素添加多个背景图片，指定多重背景不需要使用厂商前缀，如下：123456789101112131415161718div &#123; /* 备用 */ background-color: navy; /* 添加四个图片作为元素的背景，路径可以为相对路径或绝对路径 */ background-image:url(./first.png),url(./secont.png),url(./third.png),url(./fourth.png); /* 分别设置四张图片的位置 */ background-position:20% 25%,40% 105%,30% 65%,10% 75%; /* 图片重复方式 */ background-repeat:no-repeat,no-repeat,no-repeat,no-repeat;&#125;/* 上边的语法大部分都是重复的，可以简化为下面这样*/div&#123; background-color: navy; background:url(./first.png) no-repea 20% 25%, url(./secont.png) no-repea 40% 105%, url(./third.png) no-repea 30% 65%, url(./fourth.png) no-repea 10% 75%;&#125; 不透明度可以通过opacity属性为元素设置不透明度，属性值是0-1不带单位的数字，0表示完全透明，1表示完全不透明。123456.box &#123; background: #000; opacity: .5; padding: 20px; width: 420px;&#125; 生成的内容通常使用伪元素:before和:after的时候，会结合content属性，这就是所谓的“生成的内容”，生成的内容是CSS创建的，而不是用HTML生成的。用法如下：1234&lt;p&gt;This area is one of the most tranquil spaces at the Villa. As I wandered around,enjoying shade provided by sycamore and laurel trees and serenaded by splashingwater from two sculptural fountains, I couldn't help but think &amp;hellip;&lt;a href="victoria.html" class="more"&gt; Read More&lt;/a&gt;&lt;/p&gt; 现在的“read more”只是一个简单的链接，如果我们对其设置CSS：123.more:after&#123; content:" 》"&#125; 再看页面，“read more”后边多了个“ 》”，是的，这就是CSS为其加了一个这样的符号。:before表示生成html渲染页面的时候在元素前边加上你想要加的内容。 图像合并单个图片太多的话，会影响浏览器的加载及显示时长，所以我们可以把多个图片合并到一起，然后通过CSS控制显示的图片，以达到我们想要的效果。下边代码是使用的一个例子：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; /*清除掉列表前面原有的那个点*/ .documents &#123; list-style: none; &#125; .icon &#123; min-height: 16px; padding-left: 23px; /*为保证后边设置图片偏移时是相对li元素的*/ position: relative; &#125; .icon:before &#123; background-image: url(img/sprite.png); content: " "; display: block; /* 图标高度 */ height: 16px; position: absolute; /* 图标宽度 */ width: 16px; &#125; a[href$=".xls"]:before &#123; background-position: -17px 0; &#125; a[href$=".docx"]:before &#123; background-position: -34px 0; &#125; &lt;/style&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="page"&gt; &lt;ul class="documents"&gt; &lt;li&gt;&lt;a href="expenses.xls" class="icon"&gt; Business expenses&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="user-manual.pdf" class="icon"&gt;User Manual&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="story.docx" class="icon"&gt; Short story&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="brochure.pdf" class="icon"&gt; Vacation brochure&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 如果只是如上的代码，你会发现我们的背景图被我们链接给覆盖了，所以我们需要为&lt;li&gt;设置一下左内边距，且左内边距不得小于图片的宽度，否则会部分覆盖，将li{padding-left:20px}加进我们的样式表中。最后得到的效果图如下所示，是不是很神奇。]]></content>
      <categories>
        <category>从零开始HTML5与CSS3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[常见JS面试题]Map与Set]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%B8%B8%E8%A7%81JS%E9%9D%A2%E8%AF%95%E9%A2%98%2F%5B%E5%B8%B8%E8%A7%81JS%E9%9D%A2%E8%AF%95%E9%A2%98%5DMap%E4%B8%8ESet%2F</url>
    <content type="text"><![CDATA[Map和Set是ES6中新提供的两种数据类型。 Map在没有Map这种数据类型之前，键值映射通常通过object来实现。比如说：12const historyWeather = &#123; '2019-1-2': '晴', '2019-1-5': '雨'&#125;console.log(historyWeather['2019-1-2']) //输出晴 有了Map之后我们可以这样实现1234const historyWeather = new Map()historyWeather.set( '2019-1-2', '晴')historyWeather.set('2019-1-5', '雨')console.log(historyWeather.get('2019-1-5')) 这就是Map的基本用法，和其它语言hash类型基本也相似。那么为什么object能实现的功能还要重新定义一种新的类型呢？这说明它们肯定有某种区别，而这种区别就经常作为面试题。下面我们来结合例子列举他们的区别。 key的取值范围： object: 字符串或者Symbol类型（如果key是Number类型，则会先转成字符串。） Map: 所有类型。 key的遍历顺序： object: for…in遍历object时，有可能得到的是不同与插入时的顺序。 Map: 得到的是与插入时相同的顺序 迭代方式不同： object: 只能迭代出键。 Map: for…of可以迭代出键值对数组。 SetSet是一个集合。 基本用法1234567891011const mySet = new Set()mySet.add(1)mySet.add("some text")mySet.add(&#123;a: 1, b: 2&#125;)mySet.add(NaN)mySet.add(undefined)mySet.add(true)console.log(mySet.size) //6console.log(mySet) //上述值 当然上述功能换成Array，改动一下api也是能实现的。所以很自然的就有下面的 Set和Array互换123const myArray = [1,2,3,3,4,5]const mySet = new Set(myArray); //Array to Setconsole.log([...mySet]); //Set to Array and print [ 1, 2, 3, 4, 5 ] 这里有一个重要的地方，从表现上来看，myArray一来一回重复的3被删除掉了，这是因为Set的元素唯一特性。 Strng转Set12const myString = 'hello';const mySet = new Set(myString); //Set &#123;'h','e','l','o'&#125; WeakMap和WeakSet这两种数据结构分别对应Map和Set区别如下： key的值只能是对象。 对key的引用方式不同。关于这一点请看如下两段并将关注点放在对象{ a: &#39;1&#39;, b: &#39;2&#39; }。 12345678910let obj = &#123; a: '1', b: '2' &#125;;const myMap = new Map();myMap.set(obj, '1');obj = null;for (entry of myMap)&#123; console.log(entry) //[&#123;a:'1',b:'2'&#125;,'1']&#125;//&#123; a: '1', b: '2' &#125;并不会被回收，因为除了obj引用了对象&#123; a: '1', b: '2' &#125;，//myMap也引用了对象&#123; a: '1', b: '2' &#125;。//本列将obj的引用设置为了空，但是myMap中任然对&#123; a: '1', b: '2' &#125;有直接引用关系。 1234567let obj = &#123; a: '1', b: '2' &#125;;const myMap = new WeakMap();myMap.set(obj, '1');obj = null;//&#123; a: '1', b: '2' &#125;会被回收，此时myMap中将不会再有[&#123;a:'1',b:'2'&#125;,'1']这个Entry。//因为myMap并不会直接引用&#123;a:'1',b:'2'&#125;，你可以理解为它是引用obj变量间接应用&#123;a:'1',b:'2'&#125;，//所以obj不引用&#123;a:'1',b:'2'&#125;，&#123;a:'1',b:'2'&#125;将被GC。myMap也会因为不能将null作为键而删除这条记录。 有第二点铺垫非常容易推出第三点：Weak版本是不能枚举的。因为其键随时可能被非显示删除，如果可以枚举，枚举它将得到不确定的结果。]]></content>
      <categories>
        <category>常见JS面试题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[从零开始HTML5与CSS八]-构建响应式页面]]></title>
    <url>%2F2019%2F03%2F25%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS3%2F%5B%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS%E5%85%AB%5D-%E6%9E%84%E5%BB%BA%E5%93%8D%E5%BA%94%E5%BC%8F%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[上一篇文章中有提到，网页布局一般有固定布局与响应式布局，固定布局没什么说的，只需根据你的需求设定元素的宽度和高度即可，这篇文章主要讲下构建一篇响应式布局的页面主要从哪些方面开始。 创建可伸缩图像我们知道引入到页面中的文件，本身是有大小的，如果不为其设置width和height的话，引入的就是原始尺寸，那对我们的页面来说，可能会过大，所以我们需要为其设置合适的尺寸，但是，如果浏览器窗口变窄的话，可能我们之前设置的尺寸又不太合适了，所以为了让我们的图像使用的场景更多，我们将图像设置为可伸缩图像，即将图像的max-width属性这样设置：max-width:100%;,这样图像就可以根据其包含元素的大小，自动伸缩进行调整，但是最大的宽度也不会超过图像本身的宽度。 创建弹性布局如果我们将页面的宽度全部都设置成固定大小，难免过于死板，如果浏览器窗口域小于页面宽度的话，就会出现横条，这并不是我们希望看到的，我们希望可以页面可以像图像一样自由伸缩，弹性布局（又称流式布局）就可以满足这个需求，将包含整个页面的元素设置为：max-width:x px。x的值是你希望的页面最大宽度，x的单位一般是像素，但是你也可以使用em、rem以及百分数等相对单位，然后所有的后代元素都设置为百分数或者em相对单位，百分数的大小由你想要设置的宽度大小除以父元素的宽度大小即可的得到。这样我们的页面也可以根据浏览器窗口的大小进行自动调节了。 理解和实现媒体查询我们之前构建的页面，以及页面的适应性都是在PC端的基础上，在移动端上查看我们的页面的话，可能仅仅是缩小页面，字体什么的可能就会变得非常小，不易于查看，所以我们可以通过媒体查询选择元素来为其设置样式，以达到在不同的屏幕大小的设备上都能正常的查看我们的页面。引入媒体查询语法的方式一般有以下两种： 外部样式表链接通过设置link的media属性，满足某一条件的媒体会选择相应的css文件为页面设置样式。 12345678&lt;head&gt;&lt;!-- 适配宽度大于等于480px的媒体--&gt;&lt;link rel="stylesheet" media="only screen and (min-width: 480px)" href="styles-480.css" /&gt;&lt;!-- 适配宽度小于等于767px的媒体--&gt;&lt;link rel="stylesheet" media="only screen and (max-width: 767px)" href="styles-767.css" /&gt;&lt;!-- 适配宽度大于等于480px且小于等于767px的媒体--&gt;&lt;link rel="stylesheet" media="only screen and (min-width: 480px) and (max-width: 767px)" href="styles-767.css" /&gt;&lt;/head&gt; 在样式表中通过“@media”进行媒体查询，并设置其CSS 1234567891011&lt;head&gt; &lt;style&gt; /*-- 适配宽度小于等于767px的媒体*/ @media only screen and (max-width: 767px) &#123; p &#123; color: red; font-weight: bold; &#125; &#125; &lt;/style&gt;&lt;/head&gt; 我们来看下上述语句中的语法：logic（逻辑）部分是可选的，其值可以是only或not。only关键字可以确保旧的浏览器不读取余下的媒体查询，同时一并忽略链接的样式表。not关键字可以对媒体查询的结果求反，让其反面为真。例如，使用 media=”not screen” 会在媒体类型为 screen 以外的任何类型时加载样式表。type（类型）部分是媒体类型，如screen、print 等。feature: value对是可选的，但一旦包含它们，它们必须用括号包围且前面要有 and 这个字。feature 是预定义的媒体特性. 对 color、color-index 和 monochrome 特性来说，value是可选的。 可以包含在媒体查询中的媒体特性有width（宽度）、height（高度）、device-width（设备宽度）、device-height（设备高度）、orientation（方向）、aspect-ratio（高宽比）、device-aspect-ratio（设备高宽比）、color（颜色）、color-index（颜色数）、monochrome（单色）、resolution（分辨率）、scan（扫描）、grid（栅格）。]]></content>
      <categories>
        <category>从零开始HTML5与CSS3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[从零开始HTML5与CSS七]使用CSS布局页面]]></title>
    <url>%2F2019%2F03%2F20%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS3%2F%5B%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS%E4%B8%83%5D-%E4%BD%BF%E7%94%A8CSS%E5%B8%83%E5%B1%80%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[使用html标签渲染出的页面，错误是没有什么错误，但是页面着实不好看，我们这张主要用CSS调整下页面布局，在开始调整布局之前，我们还是先学习一些基本知识。 布局方法常用的布局主要有两种布局：固定布局和响应式布局。固定布局，顾名思义，就是页面内元素的元素的宽度均是固定的，无论是在PC端还是移动端，查看固定布局页面，其元素的宽度都是不变的，一般单位都是像素。响应式布局，页面内的元素的单位一般是使用em这种相对单位或者是百分比，这样页面可以自动适应界面的大小。不管是哪种布局都无法通用于所有场景，但是我们最好还是使用响应式布局，试用场景更多一点。 盒子模型CSS一般认为HTML的元素是包裹在一个无形的盒子内。盒子由内容、内边距（padding）、边框（border）以及外边距（margin）组成。css中设置元素的width一般是指内容的宽度，高度也是内容的告诉，浏览器中对元素宽度的定义有所不同，他是指内容的宽度+左右边距+边框款+左右外边距宽度。如果你想要css中设置的宽度与浏览器中的一致，只需将元素的box-sizing属性设置为border-box即可。 元素的浮动以及浮动的消除元素按照在html文件中出现的次序显示在页面中的现象叫做文档流。如下一段代码，正常情况下图片是在元素p的上方的，但是很明显图片右边空出一块区域,，如果你想要充分利用这块区域，可以通过设置图片的float属性，使文字围绕在图片的周围，（lef：图片在文字的右边；right：图片在文字的左边；center：图片被文字包围在中间。）在这里我们先将float的值设置为left。效果图如下：12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;style&gt; img&#123;float:left;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;section&gt; &lt;img src="./qiyaya.jpg"/&gt; &lt;div&gt; &lt;p&gt;daoDHoihdksjHDOIASJDKLAS CDSKJFLDSJKfvndjkshgfkldslw JDKAFDHKJSAHFDOISA&lt;/p&gt; &lt;/div&gt; &lt;footer&gt; @hasodansjdkhasi &lt;/footer&gt; &lt;/section&gt; &lt;/body&gt;&lt;/html&gt; 咦，你是不是发现我们的页脚footer也在图片的右边了，为什么会这样呢，你把section的背景色调的稍微明显一点，可以发现，section的高度等于文字的高度，而不等于图片的高度，这是因为图片现在是浮动元素，已经脱离了文档流，不影响父元素的高度了。那我们怎么让footer元素在图片的下方呢？很简单，只需要在footer这里清除掉元素的浮动即可，设置footer的属性clear值为left。浮动一旦被清除掉后，就不会再对后续的元素造成影响。我们再看另一种元素浮动的情况，代码如下：123456789101112131415161718192021222324252627282930313233343536&lt;head&gt; &lt;style&gt; .page&#123; width:960px; border:1px solid red; &#125; .main&#123; width:600px; float:left; &#125; .aside&#123; width:300px; float:right; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="page"&gt; &lt;div class="main"&gt; dhsaofhdsuhfjds dhsaofhdsuhfjds dhsaofhdsuhfjds dhsaofhdsuhfjds dhsaofhdsuhfjds &lt;/div&gt; &lt;div class="aside"&gt; dhsaofhdsuhfjds dhsaofhdsuhfjds dhsaofhdsuhfjds dhsaofhdsuhfjds &lt;/div&gt; &lt;/div&gt; &lt;footer&gt; @tesdhasjahkjds &lt;/footer&gt;&lt;/body&gt; 页面效果如下：我们为class为page的元素设置了边框，为什么只看到一条线？看一下这个div元素的高度，竟然为0，为什么呢？不要忘了，我们前边提到过，浮动元素不影响父类的高度，而这个div除了浮动元素外，并没有其他的元素，所以其高度为0，我们当然可以像之前那样，为了让之后的元素不受浮动元素的影响，在浮动元素后边的元素中，使用clear清除掉浮动，但是这样子，浮动元素的父类高度依然为0，如果这个时候我们想为这个父元素加一个背景色，是无法达到预期的。怎么办呢？解决办法是让这个父元素自身具有清除浮动的能力，最可靠的是使用所谓的 clearfix 方法。只需要为父元素添加一个clearfix类即可，clearfix的样式规则如下：1234567891011.clearfix:before,.clearfix:after &#123; content: " "; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; zoom: 1;&#125; 再看我们的页面，这个父元素被撑起来了，边框也可以按照预期那样显示了。我们并不会在每个页面中都遇到这种情况，但是最好还是在css文件中添加一下这个class，有益无害。 控制元素的显示与可见性 元素的显示形式我们知道在html中有块级元素和行内元素，大多数浏览器都会将未命名的元素标签渲染为行内元素，所以我们可以把一些低版本浏览器无法识别的元素先设置为块级元素,将元素的样式属性设置为display:block。如果想要块级元素显示为行内元素，可以通过将元素的样式属性设置为display:inline。我们知道，行内元素是不能设置高度和宽度的，如果你想为其设置，可以将行内元素display属性值设为：inline-block。这样元素依然是行内元素，但是可以为其设置块级元素才能设置的属性。 元素的可见可以通过visibility属性控制元素的可见性，visibility:hidden表示元素的不可见，浏览器渲染时会为元素保留在文档流中的位置，留下一片空白区域，display:none也可以表示文件不可见，但是这样浏览器渲染时，不会为其保留位置，后续元素会补上其在文档流中的位置，visibility:visible表示元素可见。 相对定位在前面我们提到过，每个元素在文档流都有一个自然位置，相对定位就是相对其在文档流原本的位置进行的移动，偏移后，文档流依然会为他保留以前的位置，其他元素也不会受偏移元素的影响，依然按照正常文档流显示。一般写法如下：123456/*相对自然位置向下偏移35px,向右偏移100px(这些属性值也可以为负数，表示与正数相反的方向偏移)*/.main &#123; position: relative; top: 35px; left: 100px;&#125; 绝对定位绝对定位是相对其已定位的最近祖先元素位置的偏移，如没有已定位祖先元素，则是相对body的偏移，偏移后，文档流不会为他保留以前的位置。绝对定位的元素脱离了文档流，偏移后位置周围的元素并不知道这个元素的存在，这个元素也不知道其他元素的存在。123456/*相对body向下偏移35px,向右偏移100px*/.main &#123; position: absolute; top: 35px; left: 100px;&#125; 完全定位完全定位是相对浏览器窗口的定位，无论是相对定位还是绝对定位，当我们滑动页面的时候，这些元素还是会随着滑动上下移动的，但是完全定位不会。123456/*相对body向下偏移35px,向右偏移100px*/.main &#123; position: fixed; top: 35px; left: 100px;&#125; 使用了相对定位、绝对定位和固定定位以后，很可能会遇到元素相互重叠的情况，怎么设置其覆盖情况呢？设置元素的z-index属性即可，z-index属性值为不带单位的数字，数字越大，元素的显示越靠上。如果你对元素设置position: static；将覆盖position: absolute;和position: relative; 的设置。static 是元素定位的默认值。]]></content>
      <categories>
        <category>从零开始HTML5与CSS3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[从零开始HTML5与CSS六]-构造选择器]]></title>
    <url>%2F2019%2F03%2F15%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS3%2F%5B%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS%E5%85%AD%5D-%E6%9E%84%E9%80%A0%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[上一篇我们提到过，CSS的样式规则由选择器和声明块两部分构成。这篇我们主要介绍下选择器的构成。通常有以下五种选择器，这些选择器也可以任意组合使用，大多数情况下只用一种或者两种即可。 我们接下来的选择器均是对下述这段代码的操作。123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;a page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;article id="gaudi" class="architect"&gt; &lt;h1&gt;Antoni Gaudí&lt;/h1&gt; &lt;p id="firstP" class="intro"&gt;Many tourists are drawn to Barcelona to see Antoni Gaudí's incredible architecture.&lt;/p&gt; &lt;p id="secondP"&gt;Barcelona celebrated the 150th anniversary of Gaudí's birth in 2002.&lt;/p&gt; &lt;h2 lang="es"&gt;La Casa Milà&lt;/h2&gt; &lt;p id="thirdP" class="highlight"&gt;Gaudí's work was essentially useful. &lt;span lang="es"&gt;La Casa Milà&lt;/span&gt; is an apartment building and &lt;em&gt; real people&lt;/em&gt; live there.&lt;/p&gt; &lt;/article&gt; &lt;h2 lang="es"&gt;La Sagrada Família&lt;/h2&gt; &lt;p id="fouthP" class="introduce highlight"&gt;The complicatedly named and curiously unfinished Expiatory Temple of the Sacred Family is the &lt;em&gt;most visited&lt;/em&gt; building in Barcelona.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 根据元素名称构造选择器根据元素名称选择很简单，如下所示,所有的p元素的字体样式均被设置为红色。标题元素则未发生变化。123p&#123; color:red;&#125; 如果你想对不同的元素设置相同的样式，不必选择不同的元素然后分别为其设置相同的样式，如下所写，即可同时设置h1,h2元素的字体均为红色。不同的元素名称中间使用“，”隔开。123h1,h2&#123; color:red;&#125; 根据元素的上下文构造选择器CSS可以根据元素的祖先，父元素，子元素，同胞来定位元素。 通过祖先定位元素如果想要设置某个元素内的所有后代元素的样式，如下代码选择了article元素下边所有的p元素，两个元素中间一定要有空格，表示p是article的后代元素。 123article p&#123; color:red;&#125; 通过父元素定位元素如果只想要定位某个元素内的所有子元素的，并不涉及其孙元素等其他后代元素，可以使用“&gt;”符号。如下代码选择了article元素的直接子元素p。 123article&gt;p&#123; color:red;&#125; 通过相邻同胞元素定位元素通过相邻同胞元素定位元素是使用“+”符号，如下所示，需要注意的是使用这个定位到只是元素p的紧挨着的h2同胞元素，中间有其他同胞元素的h2无法通过该符号定位到。 123article p+h2&#123; color:red;&#125; 根据元素的类名或者ID名构造选择器 根据元素的类名构造选择器在你想选择的元素类名前加“.”即可，如下所示是将第一个段落的字体颜色设置为红色。多个元素的类名可以相同，对该类设置的属性可以应用到所有的使用了该类的元素中。 123.intro&#123; color:red;&#125; 如果定位有两个类名的元素，两个类名中间不能使用空格，如下所示,如果使用空格则定位到class为introduce的元素的子元素中class为highlight的元素。 123.introduce.highlight&#123; color:red;&#125; 根据元素的ID名构造选择器在你想选择的元素类名前加“#”即可，如下所示是将第一个段落的字体颜色设置为红色。一般不推荐使用ID选择器，使用ID选择器，表示选择唯一的元素，不够灵活。 123#firstP&#123; color:red;&#125; 根据伪元素或者元素的伪属性构造选择器 根据伪元素构造选择器如果你只想设置某个元素的第一个子元素或者最后一个子元素的样式，只需要通过以下代码即可,注意元素与伪元素之间千万不要使用空格，且伪元素的前面需要加上“:”。 12345678910111213141516/*article的第一个子元素`&lt;h1&gt;Antoni Gaudí&lt;/h1&gt;`的字体设置为红色*/article:first-child&#123; color:red;&#125;/*article的最后子元素--第三个段落的字体设置为红色*/article:last-child&#123; color:red;&#125;/*每个段落的首行字体为红色*/p:first-line&#123; color:red;&#125;/*每个段落的首个字母字体为红色*/p:first-letter&#123; color:red;&#125; 根据元素的伪类构造选择器CSS可以根据链接的当前状态设置链接的样式。一般用:link，:visited,:focus,:hover,:active这几个伪类来表示相应的状态，注意为这些伪类设置样式最好是按照这个顺序来，不然可能会出现格式覆盖的问题，例如已经点击过的链接呈现出的未点击时的样式。也可以对p等元素使用hover等伪类。 1234567891011121314151617181920/*一个未被点击过的链接*/a:link&#123; color:green;&#125;/*一个已被点击过的链接*/a:visited&#123; color:red;&#125;/*一个获取焦点的链接*/a:focus&#123; color:orange;&#125;/*鼠标悬停在此处的链接*/a:hover&#123; color:blue;&#125;/*一个被激活的链接*/a:active&#123; color:green;&#125; 根据元素是否含有某些属性或者某些属性值构造选择器查看某些元素是否包含某些属性或者属性值的匹配原则如下：123456789101112131415161718192021222324252627/*匹配到属性值是intro的元素*/ p [class ="intro"]&#123; color:red; &#125;/*匹配到属性值为intro开头，且intro为一个完整的单词的元素。下示代码只会匹配到第一个段落，不会匹配到第四个段落。*/ p [class ~="intro"]&#123; color:red; &#125;/*匹配到属性值为"intro"或者是以"intro-"开头的元素。*/ p [class |="intro"]&#123; color:red; &#125;/*匹配到属性值为intro开头，且intro可以为一个的单词的一部分或一个完整的单词的元素。*/ p [class ^="intro"]&#123; color:red; &#125;/*匹配到属性值由intro结尾，且intro可以为一个的单词的一部分或一个完整的单词的元素。*/ p [class $="intro"]&#123; color:red; &#125;/*匹配到属性值包含intro，可在单词的开头中间结尾任意位置的元素。*/ p [class *="intro"]&#123; color:red; &#125;]]></content>
      <categories>
        <category>从零开始HTML5与CSS3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[从零开始HTML5与CSS3五]CSS基础知识简介]]></title>
    <url>%2F2019%2F03%2F13%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS3%2F%5B%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS3%E4%BA%94%5D-CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[我们前边几遍文章介绍了HTML5中的一些常用标签，由这些标签构造出来的页面，可以说是一点也不美观，所以接下来我们就学习CSS,来美化我们的web界面，本篇主要介绍下CSS入门的一些基本知识点。 CSS的构成一个CSS语句主要是由选择器，以及声明块构成，如下所示。声明块由一个大括号包含着声明语句，每条声明语句包含一个属性与属性值，以分号结束。一个声明块里可以包括多条声明，不同名属性的声明先后不影响显示效果。123p&#123; color:red;&#125; CSS的继承以及属性取值CSS的继承在说什么是CSS的继承前，我们先看如下一段代码：12345678910&lt;body&gt; &lt;div&gt; &lt;h1&gt;The Ephemeral Blue Flax&lt;/h1&gt; &lt;img src="img/blueflax.jpg" width="300" height="175" alt="Blue Flax (Linum lewisii)"/&gt; &lt;p&gt;I am continually &lt;em&gt;amazed&lt;/em&gt; at the beautiful,delicate Blue Flax that somehow took hold in my garden.They are awash in color every morning, yet not a single flower remains by the afternoon. They are the very definition of ephemeral.&lt;/p&gt; &lt;p&gt;&lt;small&gt;&amp;copy; Blue Flax Society. &lt;/small&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 在学习html的时候，我们知道上边这段代码中，body元素是所有的其他元素的父元素，h1、img、p又是div的子元素，等等。如果我们给body的设置样式如下：1234body&#123; color:red; border:1px solid black;&#125; 可以发现，不仅body的字体颜色变为红色，body子元素的字体也变成了红色，这就是CSS的继承，子元素继承了父元素的样式，所以如果你想让全篇的文章字体都是一样的，只需在body里边设置你想要的字体颜色及样式即可，无需单独设置每个元素的样式。你是不是也发现了，我们还给body设置了border的样式，但是只有body有边框，子元素并没有边框，这是为什么呢？原来并不是所有的样式属性都可以被继承，具体那些可以被继承，哪些不可以，你可以参考《HTML5与CSS3基础教程》（第8版）第七章，里边有列出。但是如果你就是想继承父类的边框，怎么办呢，很简单！只需要在border的属性值赋值为inherit即可，如下所示：123h1&#123; border:inherit&#125; CSS的属性值 CSS的属性值可以是从父元素继承来的，如上边所示：一个“inherit”。 也可以是一些预定义值，比如：text-align的属性值必须是：left、right、center、justify（实现两端对齐文本效果）中的其中一个。 CSS大部分的属性值都是长度，长度一般都是数字，且必须带单位，唯一一个例外是属性值为0时，带不带单位效果一样，所以一般就不带。常见的单位有：em,1em约等于对应元素的字号大小，如果em是用来设置元素本身的font-size,1em则是该元素的父元素字号大小；px，1px就是一个像素，不同设备上的1个像素的大小可能也不一样，所以为了在不同设备上都能正常浏览我们的web页面，一般不适用px作为单位；pt，应该在为打印准备的样式表中保留这个单位。 CSS的属性值还可以是百分数，和em类似，都是相对性的值，一般是相对父元素的属性值。 只有极少数的 CSS 属性接受不带单位的数字，如 3、0.65。其中最常见的就是 lineheight、z-index 和 opacity。如下代码中的1.5表示，将字号大小乘以1.5得到行高。 1line-height: 1.5; CSS的属性值有很多是表示颜色的一般使用RGB、RGBA，HSL,HSLA和十六进制表示颜色.RGB括号中的数值可以是0-256中间的任意值，如RGB(89, 0, 127)，第一个是表示颜色中红色的量，第二个是表示颜色中绿色的量，第三个是表示颜色中蓝色的量，也可以是百分数，如(35%, 0%, 50%)，35%是256的35%。也可以是16进制，如#59007F，如果16进制表示颜色的值是：#00FF00，也可以写作：#0F0。RGBA括号中的值比RGB多了一个alpha透明度的值，一般写法：RGBA(89, 0, 127,0.75),0表示完全透明，1表示完全不透明。HSL的含义是色相（hue）、饱和度（saturation）和亮度（lightness），其中色相的取值范围为0-360，饱和度和亮度的取值均为百分数，范围为0-100%，其中0和360均表示红色，HSL和HSLA的区别与RGB和RGBA的区别一样，但有的浏览器可能不支持RGBA，HSL,HSLA这三种格式，所以最好是在先用RGB或者是十六进制定义一下颜色，在不支持后三者的浏览器中，浏览器会自动忽略掉该条语句，也不会影响颜色的正常显示。 CSS的属性值还可以是一个URL，如：background: url(bg-pattern.png)，这表示引入一个图片做为选定元素的背景。 CSS的优先级CSS是层叠样式表，如果给同一个元素的同一个属性值多次赋值，浏览器是怎么取舍这些属性值呢？CSS中有一些规则，来评定优先级。 通过权重决定优先级 开篇我们就说过CSS是由选择器和生命块构成的，如果是通过ID选择器选择的文本，权重最高，通过类选择器选择的文本，权重第二，通过元素选择器选择的文本，权重最低。三种选择器的写法如下：123456789101112131415161718192021&lt;html&gt; &lt;head&gt; &lt;style&gt; /*元素选择器*/ p&#123; color:red; &#125; /*类选择器*/ .pClass&#123; color:green; &#125; /*ID选择器*/ #pId&#123; color:blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;P class = "pClass" id = "pId"&gt;test test test&lt;/P&gt; &lt;/body&gt;&lt;/html&gt; 如果同时以这三种方式为p元素设置字体颜色，则最终文本显示的颜色为通过ID选择器设置的颜色，上边的例子中P元素的字体颜色为blue。 通过距离决定优先级12345&lt;body style="color:green"&gt; &lt;div style="color:red"&gt; &lt;p&gt;test test test&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 顾名思义，就是距离被设置元素的距离越近，优先级越高。如上所示，如果父元素设置了字体的颜色为红色，父元素的父元素的颜色为绿色，则p元素文本的颜色为红色，如果你又通过&lt;p style =&quot;color:blue&quot;&gt;test test test&lt;/p&gt;,设置字体的颜色，p元素文本的颜色为蓝色。 通过特别属性值决定优先级如果实际情况某条css样式的优先级不是很高，但是你又想让浏览器优先使用这个属性值，可以为这个属性值后边加上“!important”，用法如边的代码所示，这样P元素的文本颜色就是红色了，但这样子做，很难维护，所以不到万不得已，尽量不要使用“!important”。123456789101112131415161718192021&lt;html&gt; &lt;head&gt; &lt;style&gt; /*元素选择器*/ p&#123; color:red !important; &#125; /*类选择器*/ .pClass&#123; color:green; &#125; /*ID选择器*/ #pId&#123; color:blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;P class = "pClass" id = "pId"&gt;test test test&lt;/P&gt; &lt;/body&gt;&lt;/html&gt; html中引入样式表的方式 嵌入样式表：如果你的CSS的内容很少，你可以直接将其以&lt;style&gt;标签包裹，放在&lt;head&gt;标签内，如下所示： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;style&gt; img &#123; border: 4px solid red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="img/palau.jpg" width="250" height="163" alt="El Palau de la Música" /&gt; &lt;/body&gt;&lt;/html&gt; 链接外部样式表：但是如果你的CSS内容很大，再放入html文件中，难免看起来很混乱，这时你可以把你的CSS设置单独放在一个.css格式的文件中，然后以如下代码所示的方式将这个css文件引入到html中，属性href的值是存放文件的地址，可以是相对路径，也可以是绝对路径。 123456789&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;link href="mystyle.css" rel="stylesheet" type="text/css"/&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="img/palau.jpg" width="250" height="163" alt="El Palau de la Música" /&gt; &lt;/body&gt;&lt;/html&gt; 应用内联样式：还有一种方式使用样式表，就是直接在元素上使用style属性，如下所示，这种方式只能影响单个元素，繁琐且不易维护，所以不推荐使用。 1234567&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;body&gt; &lt;img src="img/palau.jpg" width="250" height="163" alt="El Palau de la Música" style="border: 4px solid red" /&gt; &lt;/body&gt;&lt;/html&gt; 这三种使用样式表的方式的优先级是，如果嵌入样式的引入在外部样式的前边，则会被外部样式覆盖掉，如果在其后边，则会覆盖外部样式的样式，内联样式，由于是直接作用于元素上，所以优先级最高。]]></content>
      <categories>
        <category>从零开始HTML5与CSS3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[从零开始HTML5与CSS四]web常用图像格式介绍以及页面图标的添加]]></title>
    <url>%2F2019%2F03%2F07%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS3%2F%5B%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS%E5%9B%9B%5D-web%E5%B8%B8%E7%94%A8%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E9%A1%B5%E9%9D%A2%E5%9B%BE%E6%A0%87%E7%9A%84%E6%B7%BB%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[图像在web页面是一种很常见的元素，我们这篇就主要学习一下常用的图像格式，以及他们之间的优劣，最后呢，再讲一下怎么给web页面添加图标。 常用的图像格式常用的图像格式一般是JPEG,PNG,GIF。下边我们依次介绍这几个格式的优缺点。 JPEG格式 JPEG有1600万种颜色，很适合用于彩色图片，而且JPEG格式对文件进行了合理的压缩，这样文件就很小，下载起来就很快。 JPEG是有损格式，即在对文件进行压缩时，会丢失文件的一些原始信息，而且压缩后，即使对文件再进行解压缩，也无法还原原始信息，所以在不确定后续是否还需对原文件进行编辑时，最好还是先备份一份。另外在使用JPEG压缩文件时，最好是将文件维持在损失信息无法被客户察觉，文件大小又得到很大压缩的程度。 PNG格式 PNG格式是无损格式，有几百万种颜色，一般用作大量纯色图片、重复图片、标识、以及图片文字等文件。PNG格式又可分为PNG-8,PNG-24,PNG-32三种格式。PNG-8有256种颜色，支持索引色透明和alpha透明，但是在photoShop图片编辑工具中不支持alpha透明；PNG-24有1600万种颜色，支持索引色透明；PNG-24有1600万种颜色，支持索引色透明和alpha透明，而且在photoShop图片编辑工具中依然支持alpha透明。 PNG格式的文件比较大，下载速度慢，所以除非文件使用JPEG压缩时，会损失大量原始信息，一般不使用PNG格式。 GIF格式 GIF格式也是无损格式，和PNG格式差不多，主要区别是：GIF仅有256种颜色，GIF支持对动画的保存，GIF只支持索引色透明。除了动画必须用GIF格式外，平时使用时，一般优先选择PNG格式，因为PNG格式对透明度的支持更好，对压缩算法的计算也更好。 索引色（基本）透明就是要么不透明，要么就完全透明，alpha透明可以对透明度进行调整，可以做到部分透明。 图标的添加打开一个网页是我们有时会看到网页的标题左边有个小图标，怎么为我们的web页面添加一个图标呢？很简单： 创建一个 16×16 的图像，并保存为ICO 格式，文件名为 favicon.ico。作为可选步骤，为 Retina 显示屏创建一个 32×32 的图像。ICO 文件允许在同一个文件中包含多个不同尺寸的同名文件。 （推荐）为触屏设备至少创建一个图像，并保存为 PNG 格式。如果只创建了一个，将其命名为 apple-touchicon.png。如有需要，还可以创建其他的触屏图标。 将图标图像放在网站的根目录里。浏览器会自动在根目录寻找这些特定的文件名，找到后就将图标显示出来。]]></content>
      <categories>
        <category>从零开始HTML5与CSS3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[从零开始HTML5与CSS3三]-文本内常用标签的介绍]]></title>
    <url>%2F2019%2F03%2F05%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS3%2F%5B%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS3%E4%B8%89%5D-%E6%96%87%E6%9C%AC%E5%86%85%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[我们上一篇介绍了HTML5中新增且常用的一些标签，可以发现，除非一个页面中大部分都是图片，否则一个页面的主要内容还是文本，这一篇，我们就介绍一些文本中常用的标签 新增段落html中会自动忽略空格符与换行符，所以想要写几个段落的话我们就可以使用&lt;p&gt;标签，如下所示：12345678910&lt;body&gt; &lt;h1&gt;Antoni Gaudí&lt;/h1&gt; &lt;p&gt;Many tourists are drawn to Barcelonato see Antoni Gaudí's incredible architecture.&lt;/p&gt; &lt;p&gt;Barcelona celebrated the 150th anniversary of Gaudí's birth in 2002.&lt;/p&gt; &lt;h2 lang="es"&gt;La Casa Milà&lt;/h2&gt; &lt;p&gt;Gaudí's work was essentially useful. &lt;span lang="es"&gt;La Casa Milà&lt;/span&gt; is an apartment building and real people live there.&lt;/p&gt; &lt;h2 lang="es"&gt;La Sagrada Família&lt;/h2&gt; &lt;p&gt;The complicatedly named and curiously unfinished Expiatory Temple of the Sacred Family is the most visited building in Barcelona.&lt;/p&gt;&lt;/body&gt; 细则说明有的时候在页面中我们会看到一些小字体，比如免责声明，注意事项，网页信息，这是使用了&lt;small&gt;标签，通常&lt;small&gt;标签被用于行内元素。123&lt;body&gt; &lt;p&gt;Order now to receive free shipping.&lt;small&gt;(Some restrictions may apply.)&lt;/small&gt;&lt;/p&gt;&lt;/body&gt; 重要内容和强调内容以前的html都是使用&lt;b&gt;标签加粗文本，使用&lt;i&gt;标签标示斜体文本，但是这些并不能表达出我们想要表达的重要性和强调点，html4中直接废弃掉这两个标签，而html5中仅仅使用这两个标签表示一些固有名词，动物名称等，采用&lt;strong&gt;标记重要的内容，需要重点强调的用&lt;em&gt;标签，浏览器通常将strong 文本以粗体显示，将em文本以斜体显示。这两个标签既可以分开单独使用，也可以嵌套使用如：&lt;strong&gt;Warning: Do not approach the zombies &lt;em&gt;under any circumstances&lt;/em&gt; &lt;/strong&gt;.，中间的文本以粗体加斜体显示。 引入图表有的时候，我们可能需要在一段文本介绍后，加入图形，表格进行详细说明，这个时候，我们可以使用&lt;figure&gt;和&lt;figcaption&gt;标签，用法如下：123456&lt;body&gt; &lt;figure&gt; &lt;figcaption&gt;&lt;b&gt;Figure 3:&lt;/b&gt;Breakdown of Revenue by Industry&lt;/figcaption&gt; &lt;img src="chart-revenue.png" width="180" height="143" alt="Revenue chart: Clothing 42%, Toys 36%, Food 22%" /&gt; &lt;/figure&gt;&lt;/body&gt; &lt;figure&gt;包含了即将引入的图表内容，如果图片有标题的话，可以使用可选标签&lt;figcaption&gt;。 引用标签html5使用&lt;cite&gt;标签表示对戏剧、书籍等的引用，浏览器通常将cite文本以斜体显示。 引述文本引用某本书中或者是某个电影中的一段话的时候，html5使用&lt;blockquote&gt;，使用&lt;q&gt;表示短句引用。 指定时间如想按照预想的时间格式显示时间的话，需要使用&lt;time&gt;标签，&lt;time&gt;有一个可选的datetime属性，datetime是给浏览器看的，并不会显示到页面上，如果你选择省略掉datetime属性，那你的&lt;time&gt;内的时间必须是标准模式，否则浏览器无法识别，如下代码第二行的“a.m.”是不合法的。1234&lt;!--包含datetime属性--&gt;&lt;p&gt;We began our descent from the peak of Everest on &lt;time datetime="1952-06-12T 11:05:00"&gt;June 12, 1952 at 11:05 a.m.&lt;/time&gt;&lt;/p&gt;&lt;!--不包含datetime属性--&gt;&lt;p&gt;The train arrives at &lt;time&gt;08:45&lt;/time&gt; and &lt;time&gt;16:20&lt;/time&gt; on &lt;time&gt; 2017-03-19&lt;/time&gt;.&lt;/p&gt; 定义文本有一些文本是对某类东西的命名，我们就用&lt;dfn&gt;标签。定义文本标签，只有首次定义的时候需要&lt;dfn&gt;标签，使用方法如下：12&lt;p&gt;The contestant was asked to spell "pleonasm." She requested the definition and was told that &lt;dfn&gt;pleonasm&lt;/dfn&gt; means "a redundant word or expression"(Ref: &lt;cite&gt;&lt;a href="http://dictionary. reference.com/browse/pleonasm" rel= "external"&gt;dictionary.com&lt;/a&gt;&lt;/cite&gt;.&lt;/p&gt; 上标下标上标标签是&lt;sup&gt;，下边标签是&lt;sub&gt;。使用方法如下：1234567&lt;body&gt; &lt;p&gt;CO&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt; &lt;footer&gt; &lt;sup&gt;1&lt;/sup&gt;something is writed here. &lt;sup&gt;2&lt;/sup&gt;something is writed here. &lt;/footer&gt;&lt;/body&gt; 文本缩写文本缩写的标签是&lt;abbr&gt;,用法如下：1234&lt;body&gt; &lt;p&gt;The &lt;abbr title="National Football League"&gt;NFL&lt;/abbr&gt; promised a &lt;abbr title="light amplification by stimulated emission of radiation"&gt; laser&lt;/abbr&gt; show at 9 p.m. after every night game.&lt;/p&gt; &lt;p&gt;But, that's nothing compared to what &lt;abbr&gt;MLB&lt;/abbr&gt; (Major League Baseball) did. They gave out free &lt;abbr title="self-contained underwater breathing apparatus"&gt;scuba&lt;/abbr&gt; gear during rain delays.&lt;/p&gt;&lt;/body&gt; &lt;abbr&gt;的title属性的属性值一般是缩写词的含义，鼠标停留在缩写词上时会显示出来，但是手机端和ipad无法读取到title属性的值，所以我们推荐在缩写词的后边的“（）”中说明缩写词的含义。当然有些常见的缩写词，也可以不注明其含义，例如：laser（激光）、scuba（水中呼吸器）。 作者联系信息有时文本的末尾会放置作者的联系方式，或者是联系链接，html5提供了&lt;adress&gt;标签，页面以斜体显示。 代码标记html页面中代码的字体默认是等宽字体，如果你需要写一段代码，只需要使用&lt;code&gt;标签即可。 预格式化标签我们曾多次说过，浏览器会将换行和空格压缩，并根据窗口大小自动换行，如果你想要文本以如下格式在页面上呈现：123p&#123; color:black;&#125; 可以使用预格式化标签&lt;pre&gt;,预格式化标签会保持文本固有的换行和空格。 标记标签我们在看一本书的时候，有时会用荧光笔，突出重点部分，如果我们在HTML页面中也想有这样的效果呢，html5提供了&lt;mark&gt;标签给我们，只需将你希望重点突出给读者的文本，包含在&lt;mark&gt;标签内即可。1&lt;p&gt;Remove the tray from the box. Pierce the overwrap several times with a fork and cook on High for &lt;mark&gt;15 minutes&lt;/mark&gt;, rotating it half way through.&lt;/p&gt; 换行标签如果你想在文本中强制换行，使用&lt;br&gt;标签即可。 行内标签有的时候你可能只想针对行内的某一句话，或者几个单词进行属性设置，但是又没有合适的标签的时候，&lt;span&gt;是一个不错的选择，你可以对“id，class,style,width,color”等属性进行设置。 新增文本标记，删除文本标记，不准确文本如果你想在一个列表中新增几个选项并删除几个选项，新增可以使用&lt;ins&gt;标签，删除使用&lt;del&gt;标签。用法如下所示：1234567&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;del&gt;apple&lt;/del&gt;&lt;li&gt; &lt;li&gt;&lt;del&gt;banana&lt;/del&gt;&lt;li&gt; &lt;/ul&gt;&lt;/body&gt; &lt;ins&gt;和&lt;del&gt;标签也可以放在整个块外边，新增或删除整个块文本，如下：123456789&lt;body&gt; &lt;del&gt; &lt;ul&gt; &lt;li&gt;&lt;del&gt;apple&lt;/del&gt;&lt;li&gt; &lt;li&gt;banana&lt;li&gt; &lt;li&gt;&lt;ins&gt;orange&lt;/ins&gt;&lt;li&gt; &lt;/ul&gt; &lt;/del&gt;&lt;/body&gt; 不再准确文本用&lt;s&gt;标签，默认情况下，浏览器会对 s 元素添加删除线 尾语文本标签还有其他很多种，但是不经常用到，如果读者还想深入了解更多标签，可以看下《HTML5与CSS3基础教程（第8版）》第四章内容。]]></content>
      <categories>
        <category>从零开始HTML5与CSS3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[从零开始node微服务三]Seneca+Mongo实现数据持久化]]></title>
    <url>%2F2019%2F03%2F04%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bnode%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F%5B%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bnode%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%89%5DSeneca%2BMongo%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在一个真实的项目中，数据的持久化是不可避免的。在Seneca中你可以直接在定义的插件中直接使用自己的方式对数据持久化。当然也可以使用seneca-entity插件提供的ActiveRecord-style风格的接口再注册一个存储引擎实现数据持久化。个人也是建议使用seneca-entity，因为这样提供了一种快速切换底层数据持久化工具的可能。下面要介绍的也正是基于seneca-entity和MongoDB的持久化方式。 seneca-entity插件简介seneca-entity是一个Seneca插件，它提供一个简单的ORM抽象层。通过它提供的make()方法可以非常方便的创建一个包含数据库上下文的实体对象，再利用以下四个API和对应的模式操作数据库。API如下所示： api description pattern load load an entity by identifier role:entity,cmd:load,name: save create or update an entity role:entity,cmd:save,name: list list entities matching a simple query role:entity,cmd:list,name: remove delete an entity by identifier role:entity,cmd:remove,name: seneca-mongo-store插件简介seneca-mongo-store插件提供利用MongoDB实现持久化的支持。结合seneca-entity，除了需要知晓如何配置与MongoDB的连接以外，我们可以对这个插件一无所知。seneca-entity为我们封装了所有细节，你只需要熟练使用上述四个api即可。 实战插件安装npm i seneca -S（如果已经安装可以省略）npm i seneca-entity -Snpm i seneca-mongo-store -S MongoDB服务端启动 下载安装MongoDB Server。 配置启动等等请参见MongoDB教程。 代码app.js1234567891011121314151617181920const seneca = require('seneca')();const senecaEntity = require('seneca-entity');const senecaMongoStore = require('seneca-mongo-store');const productPlugin = require('./plugins/product');seneca.use(senecaEntity) .use(productPlugin) .use(senecaMongoStore, &#123; name: 'quickWeb', host: '127.0.0.1', port: '27017' &#125;);//等待插件完全初始化。seneca.ready((err) =&gt; &#123; seneca.act(&#123; area: 'product', action: 'add', category: 'food', name: '方便面' &#125;, (err, result) =&gt; &#123; //将输出：Object &#123;category: "food", name: "方便面", id: "5c7d4bd9910824170011c89a"&#125; console.log(result); &#125;);&#125;); productPlugin.js1234567891011121314151617181920212223242526272829303132333435363738const seneca = require('seneca')();module.exports = function product(options) &#123; this.add(&#123; area: 'product', action: 'fetch' &#125;, (msg, reply) =&gt; &#123; //创建包含数据引擎上下文的product实体对象。 const product = this.make('product'); //获取所有product记录。 product.list$(&#123;&#125;, reply); &#125;); this.add(&#123; area: 'product', action: 'fetch', criteria: 'byId' &#125;, (msg, reply) =&gt; &#123; const product = this.make('product'); //获取id=msg.id的product记录。 product.list$(msg.id, reply); &#125;) this.add(&#123; area: 'product', action: 'fetch', criteria: 'byCategory' &#125;, (msg, reply) =&gt; &#123; const product = this.make('product'); //获取category=msg.category的product记录。 product.list$(&#123; category: msg.category &#125;, reply); &#125;) this.add(&#123; area: 'product', action: 'add' &#125;, (msg, reply) =&gt; &#123; const product = this.make('product'); product.category = msg.category; product.name = msg.name; //保存该product记录。 product.save$((err, product) =&gt; &#123; //product.data$(false)的作用是创建只包含product实体自身属性的product对象。 reply(err, product.data$(false)); &#125;); &#125;) this.add(&#123; init: 'product' &#125;, (msg, reply) =&gt; &#123; console.log('Products plugin inited'); reply(); &#125;)&#125;]]></content>
      <categories>
        <category>从零开始node微服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[从零开始HTML5与CSS3二]-HTML5新增标签的含义及用法]]></title>
    <url>%2F2019%2F02%2F27%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS3%2F%5B%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS3%E4%BA%8C%5D-HTML5%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE%E7%9A%84%E5%90%AB%E4%B9%89%E5%8F%8A%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[上一篇文章中，我们已经学习了一个基本面的构造，但是对里边的标签并没有进行详细的解说，那我们这一篇的内容就是介绍构成一个HTML页面的常用标签的意思及用法。 上图是一个包含我们即将介绍的所有标签的页面，我们下边的介绍就结合这张图来帮助读者更好的理解标签的用法。 分级标题标签的用法上一篇我们就提到过标题总共会有六个等级，&lt;h1&gt;~&lt;h6&gt;,&lt;h2&gt;是&lt;h1&gt;的子标题，&lt;h3&gt;是&lt;h2&gt;的子标题，以此类推，一个页面中可能会有很多个标题，比如上图中的三段文章中，各个有三个小标题。我们使用的时候根据需求选择合适的标题就可以了，&lt;h1&gt;是最大的标题，h6是最小的标题。123456&lt;h1&gt;This is a H1&lt;/h1&gt;&lt;h2&gt;This is a H2&lt;/h2&gt;&lt;h3&gt;This is a H3&lt;/h3&gt;&lt;h4&gt;This is a H4&lt;/h4&gt;&lt;h5&gt;This is a H5&lt;/h5&gt;&lt;h6&gt;This is a H6&lt;/h6&gt; &lt;header&gt;&lt;nav&gt;标签的用法在浏览网页的时候，你可能会发现网页的顶端会有一些介绍性或者导航性的内容，导航具体内容就写在&lt;header&gt;标签内，导航中的链接就放在&lt;nav&gt;标签，具体写法如下：123456789&lt;header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a&gt;Barcelona's Architect &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;La Sagrada Família&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;&gt;Park Guell&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/header&gt; &lt;acticle&gt;标签的用法&lt;acticle&gt;并不是文章的意思，准确的来说，是页面，文档，应用或者网页中的一个独立的容器，可以独立出来并复用，&lt;acticle&gt;标签里可以包含段落，标题，链接，图片等元素。 &lt;section&gt;标签的用法&lt;section&gt;表示的是一个块，但是这个不同于div,div表示的是单纯的一个块，section更具有实际意义一点，比如网站的主页可以分成介绍、新闻条目、联系信息等区块。 &lt;aside&gt;标签的用法有的页面还有附注栏，比如上图中的右边的“Architectural Wonders of Barcelona”里边的内容，内容可以包含任意数量的元素。元素类型包括段落、列表、音频、视频、图像、图形等。 &lt;footer&gt;标签的用法&lt;footer&gt;标签和&lt;header&gt;标签类似，也可以放在&lt;p&gt;,&lt;article&gt;,&lt;section&gt;等标签中，表示页脚，但是&lt;footer&gt;只有父元素是&lt;body&gt;才会是页面的页脚。 给元素赋予ID或者class在创建的时候可以给元素赋予ID或者是class，ID表示的是页面唯一识别标志，一个元素可以有多个class，不同的class中间用空格分开就可以了，一个class也可以被多个元素共享，具体写法如下所示：12&lt;p id="firstP" class = "fristClass secondClass"&gt;some thing is writed here&lt;/p&gt;&lt;p id="secondP" class = "secondClass thirdClass"&gt;some thing is writed here&lt;/p&gt;]]></content>
      <categories>
        <category>从零开始HTML5与CSS3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[从零开始node微服务三]Seneca+Express发布WebApi]]></title>
    <url>%2F2019%2F02%2F26%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bnode%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F%5B%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bnode%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9B%9B%5DSeneca%2BExpress%E5%8F%91%E5%B8%83WebApi%2F</url>
    <content type="text"><![CDATA[SenecaWeb插件上一篇我们已经提到Seneca主要的功能都在插件中实现，这一篇我们则要使用Seneca一个重要的Web插件。这个插件的主要功能是根据配置的绑定规则生成对应的Web框架的路由。能生成什么框架支持的路由还要看SenecaWeb插件中实现了哪些Web框架的Adapter。已知的Adapter有： seneca-web-adapter-connect seneca-web-adapter-express seneca-web-adapter-hapi seneca-web-adapter-koa1 seneca-web-adapter-koa2 非常惊喜的发现本篇要用的Express的Adapter赫然在列。所以咋们可以非常方便的通过SenecaWeb结合Express发布Api。 集成Express看个具体的例子，下载自seneca-web代码库，docs/examples/using-express.js文件中的代码：123456789101112131415161718192021222324'use strict'var Seneca = require('seneca')var Express = require('express')var Web = require('../../')var Routes = require('./common/routes')var Plugin = require('./common/plugin')var config = &#123; routes: Routes, adapter: require('seneca-web-adapter-express'), context: Express()&#125;var seneca = Seneca() .use(Plugin) .use(Web, config) .ready(() =&gt; &#123; var server = seneca.export('web/context')() server.listen('4000', () =&gt; &#123; console.log('server started on: 4000') &#125;) &#125;) 第3行：相当于你npm i seneca-web之后require(‘seneca-web’)。第9行：该config对象在17行作为SenecaWeb插件的配置对象传入。 routes:配置web框架和pattern的映射关系。 adapter:生成框架路由时的适配器。 context:运行上下文。 第7行：引入的plugin.js文件中的代码如下。该文件用于定义Seneca模式。可以看到定义了三个模式，这三个模式将会出现在下面的routes配置中。123456789101112131415161718192021222324252627282930'use strict'module.exports = function plugin () &#123; var seneca = this seneca.add('role:todo,cmd:list', (msg, done) =&gt; &#123; done(null, &#123;ok: true&#125;) &#125;) seneca.add('role:todo,cmd:edit', (msg, done) =&gt; &#123; var rep = msg.response$ // Custom handlers send back request and response // Objects who may not have the same shape. Bear // in mind accessing these objects limits the // ability to swap frameworks easily. if (rep.send) &#123; rep.send(msg.args) &#125; else &#123; rep(null, msg.args) &#125; done() &#125;) seneca.add('role:admin,cmd:validate', (msg, done) =&gt; &#123; done(null, &#123;ok: true, args: msg.args&#125;) &#125;)&#125; 第6行：引入的routes.js文件代码如下，它赋值给config.routes作为路由配置，该对象数组的每个元素作为一个route。此路由配置文件尤为重要，文章末尾还有更详细讲述。1234567891011121314151617181920212223242526272829'use strict'module.exports = [ &#123; prefix: '/todo', pin: 'role:todo,cmd:*', map: &#123; //路由的url: Get /todo/list //路由url生成规则一：/$&#123;prefix&#125;/$&#123;key&#125;/$&#123;postfix&#125;/$&#123;suffix&#125; //得到的结果: &#123;"ok":true&#125; list: true, edit: &#123; GET: true &#125; &#125; &#125;, &#123; prefix: '/admin', pin: 'role:admin,cmd:*', map: &#123; //路由的url: Post /manage //路由生成规则二：alias属性为true，路由url为/$&#123;alias&#125;。 validate: &#123; POST: true, alias: '/manage' &#125; &#125; &#125;] 每个route配置对象的属性解释如下: prefix: 生成的web路由的前缀。 pin: 可以匹配多个模式的模式。比如pin=&#39;role:todo,cmd:*&#39;，可以匹配role=todo,cmd为任意值的模式。 map: 如果pin匹配了多个模式，每个模式在map中作为一个键再设置其它属性。可以看到两个route的map一共有三个键（list,edit,validate）分别匹配了plugin中定义的pattern。 seneca-web 路由生成。来看个具体的例子。常见Rest风格。配置:1234567891011121314const Routes = [&#123;prefix: '/user',pin: 'role:user,cmd:*',map: &#123; list: &#123;GET: true, name: ''&#125; //路由的url: Get /user/:id //路由url生成规则一：/$&#123;prefix&#125;/$&#123;key&#125;/$&#123;postfix&#125;/$&#123;suffix&#125; //其中key.name属性提供命名路由支持。此时url中$&#123;key&#125;为$&#123;key.name&#125;。 load: &#123;GET: true, name: '', suffix: '/:id'&#125;, edit: &#123;PUT: true, name: '', suffix: '/:id'&#125;, create: &#123;POST: true, name: ''&#125;, delete: &#123;DELETE: true, name: '', suffix: '/:id'&#125;, &#125;&#125;] 生成的路由： method route action GET /user role:user,cmd:list GET /user/:id role:user,cmd:load PUT /user/:id role:user,cmd:edit POST /user role:user,cmd:create DELETE /user/:id role:user,cmd:delete 这个例子是seneca-web-docs中的例子，可以说非常直观了，足以应付大部分的需求。更多更详细的配置也能从上述文档中找到。]]></content>
      <categories>
        <category>从零开始node微服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[从零开始HTML5与CSS3一]-HTML页面的构成与访问]]></title>
    <url>%2F2019%2F02%2F25%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS3%2F%5B%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BHTML5%E4%B8%8ECSS3%E4%B8%80%5D-HTML%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%9E%84%E6%88%90%E4%B8%8E%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[一个基本的HTML页面HTML页面主要是有三部分构成的：文本内容，对文件的引用，标记（HTML的M就是标记的意思）。首先我们先看一下一个基本的HTML页面应该是什么样子的：12345678910111213141516&lt;!DOCTYPE html&gt; &lt;html lang = ‘en’&gt;&lt;head&gt; &lt;meta charset = ‘UTF-8’&gt; &lt;title&gt;My First Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;article&gt; &lt;h1&gt;My First Page&lt;/h1&gt; &lt;img src=”../images/test.jpg” width = 20/&gt; &lt;p&gt; postcard always spoil my holiday,last summer ,I went to Itay,I visited the &lt;em&gt;museme&lt;/em&gt; then sat in public garenden,a friendly &lt;a href = “http://www.baidu.com“ title = ‘test web’&gt;waiter&lt;/a&gt; taugh。 &lt;/p&gt; &lt;/article&gt;&lt;/body&gt;&lt;/html&gt; 简单的介绍下尖括号（&lt;&gt;）以及它包住的元素，整个就叫做标记。HTML的标签大都是成对出现的，有开始标签如&lt;html&gt;和闭合标签&lt;/html&gt;。当然有的标签没有包含任何内容和子元素，就可以不要闭合标签，例如&lt;meta&gt;。每个元素都有着其不同的含义，例如p表示一个段落，img表示引入一个图片，a表示一个超链接等等。html5中有很多种元素，常用的就是p，article，img，a，em，h1六种，我们在下一篇文章里再详细讲解这些元素。 首先必写的是&lt;DOCTYPE&gt;标签，告诉浏览器这是一个HTML5页面，一般会写在整个页面的最前面。其次是一个html元素，在这里通过“lang”属性声明了本页面用的语言，“en”表示的是英文。接下来是head元素，这里边我们放了两个元素，一个是meta，声明了本文采用的编码是“UTF-8”，当然你也可以用任何你想用的编码，另一个是本页面的标题，会显示在打开该页面的时候，显示在地址栏。body里边包含的就是文本内容，可以看到里边有个&lt;a&gt;标签，表示一个超链接，功能是引入了一个页面，即上文所说的“对文件的引用”，ok,这就构成了一个基本的HTML页面，是不是很简单。 元素，属性，属性的值从上一段代码中可以发现&lt;img&gt;和&lt;a&gt;的尖括号里边不仅包含一个元素，还有一些其他内容，src，width,title,这些叫做它的属性，等号后面是属性的值，通常，我们会用引号包住属性的值，也可以不用引号包住，最好还是包住。有的属性值是可以取任意值，有的属性值只能取预定义值，比如“media=‘creen’”， media 属性只能设为 all、screen、print等值中的一个。有的属性值是可以取布尔值，一般可以不给属性赋值，默认是true。 HTML页面的访问方式及路径的介绍访问HTML页面常见的方式有以下三种： “http://www.test.com/test/test.html&quot; 第一种是http方式访问http是协议，是最常用的一种访问协议，还有另外一种安全协议“https”，协议后边一般跟一个:和两个//，www.test.com是主机名，/test/test.html是文件名。 “ftp://ftp.test.com/test/test.html&quot; 第二种是ftp方式访问ftp是协议，协议后边一般跟一个:和两个//，www.test.com是主机名，/test/test.html是文件名。 “mailto:1278172@test.com“ 第三种和前边两种有所不同，模式后边并没有跟//，：后边直接就是一个邮箱。常用的顺序的是http&gt;mailto&gt;ftp。 绝对路径和相对路径以及根路径讲到html的访问方式后，我们再额外介绍一下几种路径。+绝对路径是完整路径，访问不在本地的文件的时候必须要用完整路径。如：”http://www.test.com/test/test.html&quot;。+相对路径是以文件的所在位置的为起点的位置，“test2.html”表示的是同一个目录下边的文件，“../test2.html”表示的是上一层的文件夹中文件，“test/test2.html”表示的是下一级文件。+根路径是的写法是“./test3”。如果访问是一个文件，则路径的最后是文件名+文件扩展名，如果访问的是一个文件夹，路径的最后一个文件夹名和一个可选择“/”。 写在最后至此，我们已经成功建立了一个标准的HTML页面，并可以顺利访问到这个页面啦。下一篇文章将介绍常用的几个标签的具体意义及用法。]]></content>
      <categories>
        <category>从零开始HTML5与CSS3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[从零开始node微服务二]Seneca自定义插件]]></title>
    <url>%2F2019%2F02%2F24%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bnode%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F%5B%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bnode%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BA%8C%5DSeneca%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[对SenecaPlugin来自官方的介绍： When you use the Seneca framework, you write plugins all the time. They are an easy way to organize your action patterns.当你使用Sececa框架，你总是在写plugin或者在写下一个plugin的路上。它是一种组织action patterns的简单方式。A Seneca plugin is just a function that gets passed an options object, and has a Seneca instance as its this variable. You then add some action patterns in the body of the function, and you’re done. There is no callback.Seneca plugin 是一个传递option对象和拥有Seneca实例作为内部this变量值的函数。之后你在函数体中Add action patterns，你就完成了这个plugin。没有回调。 自定义插件：在Seneca中加载一个plugin的方式是使用Seneca.use()函数。use函数的定义如下： use(plugin [, options]) : thisThe .use() method provides the ability to load plugins into seneca. Plugins are the &gt;primary method of composition in Seneca and should be used liberally.§Paramsplugin - string | object…options - object… 它接收两个参数，前者是plugin本身，plugin类型的不同对应着不同的加载方式。后者是一个可选参数options，它最终会传入到plugin作为plugin的options参数。在下面的内容，将体会use()的大部分用法。 插件命名函数返回值命名前面已经说到plugin就是一个Function，所以如果让这个Function返回一个字符串，那么字符串的值就是插件的名称。请看下面这段代码：12345678910111213141516171819202122const seneca = require('seneca')();//Add a plugin 'math'.seneca.use(function () &#123; //this对象是一个Seneca instance. this.add(&#123; role: 'math', cmd: 'sum' &#125;, (msg, reply) =&gt; &#123; reply(null, &#123; answer: msg.left + msg.right &#125;) &#125;) this.add(&#123; role: 'math', cmd: 'sub' &#125;, (msg, reply) =&gt; &#123; reply(null, &#123; answer: msg.left - msg.right &#125;) &#125;) //return plugin name. return 'math';&#125;);//这里的role:'math'和plugin的名字没有关系。//输出&#123;answer:2&#125;。seneca.act(&#123; role: 'math', cmd: 'sub', left: 10, right: 8 &#125;, (err, result) =&gt; &#123; console.log(result)&#125;); 函数名称命名请看下面这段代码:12345678910111213141516const seneca = require('seneca')();//plugin name 就是函数名seneca.use(function math() &#123; this.add(&#123; role: 'math', cmd: 'sum' &#125;, (msg, reply) =&gt; &#123; reply(null, &#123; answer: msg.left + msg.right &#125;) &#125;) this.add(&#123; role: 'math', cmd: 'sub' &#125;, (msg, reply) =&gt; &#123; reply(null, &#123; answer: msg.left - msg.right &#125;) &#125;)&#125;);seneca.act(&#123; role: 'math', cmd: 'sub', left: 10, right: 8 &#125;, (err, result) =&gt; &#123; console.log(result)&#125;); 模块文件名命名请看下面这段代码:12345678910111213141516171819const seneca = require('seneca')();/* math.jsmodule.exports = function () &#123; this.add(&#123; role: 'math', cmd: 'sum' &#125;, (msg, reply) =&gt; &#123; reply(null, &#123; answer: msg.left + msg.right &#125;) &#125;) this.add(&#123; role: 'math', cmd: 'sub' &#125;, (msg, reply) =&gt; &#123; reply(null, &#123; answer: msg.left - msg.right &#125;) &#125;)&#125;*///plugin name is './math.js'.seneca.use('./math.js');seneca.act(&#123; role: 'math', cmd: 'sub', left: 10, right: 8 &#125;, (err, result) =&gt; &#123; console.log(result)&#125;); 插件初始化经过上面的内容，我们已经可以自定义一个具名的plugin并加载到Seneca中。但是我们忽略了一个重要的需求——往往我们需要知道插件加载成功与否。要实现这个需求则需要知道Seneca.use()的实现中大概有这么两行代码：1234567function use(plugin,options)&#123; //…… plugin(options); //…… seneca.act(&#123;init:'pluginName'&#125;...) //……&#125; 所以咱们只需要在plugin结束时，增加一个{init:’pluginName’}的action，在这个action中输出初始化的情况即可。如下代码所示：12345678910111213141516171819202122const seneca = require('seneca')();seneca.use(function math() &#123; seneca.add(&#123; role: 'math', cmd: 'sum' &#125;, (msg, reply) =&gt; &#123; reply(null, &#123; answer: msg.left + msg.right &#125;) &#125;) seneca.add(&#123; role: 'math', cmd: 'sub' &#125;, (msg, reply) =&gt; &#123; reply(null, &#123; answer: msg.left - msg.right &#125;) &#125;) //根据js的单线程顺序执行原则，plugin添加完action &#123;init:'math'&#125;之后说明整个plugin已经顺利load。 //act(&#123;init:'math'&#125;)也会成功输出如下信息。 seneca.add(&#123;init:'math'&#125;,(msg, reply)=&gt;&#123; console.log("plugin initialized!") reply(); &#125;)&#125;);seneca.act(&#123; role: 'math', cmd: 'sub', left: 10, right: 8 &#125;, (err, result) =&gt; &#123; console.log(result)&#125;); 插件参数前面已经提到Seneca.use()的可选参数options会传入到plugin中，接着来看一下它在实际中的使用场景吧： 更改默认配置1234567891011121314151617181920const seneca = require('seneca')();const themesPlugin = function themes(options) &#123; let defaultOptions = &#123; color: 'red', favicon: &#123; small: '/images/favicon-16x16.png' &#125; &#125; options = Object.assign(defaultOptions, options); this.add(&#123; role: 'themes', cmd: 'logOptions' &#125;, (msg, reply) =&gt; &#123; console.log(options); reply(); &#125;)&#125;;seneca.use(themesPlugin,&#123; color: "blue" &#125;);//输出 &#123; color: 'blue',favicon: &#123; small: '/images/favicon-16x16.png' &#125; &#125;。seneca.act(&#123; role: 'themes', cmd: 'logOptions' &#125;); 我们可以看到themes plugin内本身有一个默认的配置对象。我们用传入的options对象去覆盖扩展它，这样就能灵活的管理配置。 等等( ╯□╰ )，写这个小标题并不是为了搞笑，而是暂时没有想到什么其它的场景，同时也希望读者不限制自己的脑洞。]]></content>
      <categories>
        <category>从零开始node微服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[从零开始node微服务一]Seneca框架简介]]></title>
    <url>%2F2019%2F02%2F23%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bnode%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F%5B%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bnode%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%80%5DSeneca%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[来自官方的定义。 Seneca is a toolkit for writing microservices and organizing the business logic of your app.Seneca是一个用于编写微服务和组织应用程序业务逻辑的工具包。 主要关注点。Seneca的主要功能点都体现在它的插件中。Seneca框架本身实现了一套强大的插件系统，它支持以插件的方式聚合API，也就是说你要发布的API也应该以插件的方式聚合进去。在你执行完npm install seneca之后，除了seneca本身，默认的四个插件也被安装了进来。它们分别是： basicSeneca运行基础，提供以模式匹配的方式建立接口到实现的连接。为了解释清楚这个插件，请看下面两段代码： 第一段代码：12345678910const seneca = require('seneca')();seneca.add(&#123; role: 'math', cmd: 'add' &#125;, (msg, reply) =&gt; &#123; reply(null, &#123; answer: msg.left + msg.right &#125;)&#125;)seneca.act(&#123; role: 'math', cmd: 'add', left: 1, right: 1 &#125;, (err, result) =&gt; &#123; if (err) return console.log(err); console.log(result);&#125;) 第一行中的add()函数是在Seneca中注册一个pattern，add()函数的第一个参数是该pattern，第二个参数是该pattern的handle函数定义。第二行中的act()函数作用是发送msg给Seneca中注册的pattern，第一个参数是msg本身，第二个参数是handle完pattern的回调。接收到的msg会和所有Seneca中的pattern进行匹配，Seneca会选择一个有最相近的匹配的pattern处理。pattern的第一参数msg则是通过act()发送的msg。如果在控制台运行这段代码会在控制台打印出{answer:2}。 第二段代码：123456789101112131415161718const seneca = require('seneca')();seneca.add(&#123; role: 'math' &#125;, (msg, reply) =&gt; &#123; reply(null, &#123; result: "匹配到&#123;role:'math'&#125;" &#125;)&#125;)seneca.add(&#123; a: 2 &#125;, (msg, reply) =&gt; &#123; reply(null, &#123; result: "匹配到&#123;a:2&#125;" &#125;)&#125;)seneca.add(&#123; cmd: 'add', a: 2 &#125;, (msg, reply) =&gt; &#123; reply(null, &#123; result: "匹配到&#123; cmd: 'add', a: 2&#125;" &#125;)&#125;)seneca.act(&#123; role: 'math', cmd: 'add', a: 2, left: 1, right: 1 &#125;, (err, result) =&gt; &#123; if (err) return console.log(err); console.log(result);&#125;) 之前有说到Seneca的最相近匹配原则，那什么叫做最相近呢？如果执行上面这段代码，如果在控制台运行这段代码会在控制台打印出{result:&#39;匹配到{cmd:&#39;add&#39;,a:2}&#39;}。越多相同的属性越优先匹配。 web提供生成web api路由的功能，将Seneca中的模式生成为某种规则的web api routes。 transport提供两个远程Seneca端之间基于http和tcp的通信通道。 men-store提供开箱即用的内存存储功能，非常适合在编写单元测试时使用。 写在最后文章结束的时候，我们已经知道Seneca最主要的就是插件系统，那么如何用插件的方式聚合Api呢？下一篇文章将介绍如何将API定义在插件中聚合到框架内。GitHub-senecajs/seneca]]></content>
      <categories>
        <category>从零开始node微服务</category>
      </categories>
  </entry>
</search>
